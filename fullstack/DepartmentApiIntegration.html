 <llm-snippet-file>static/pages/department.html</llm-snippet-file>
 ```html
 <!DOCTYPE html>
 <html lang="en">
 <head>
  <meta charset="UTF-8" />
  <title>Departments</title>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
  <link rel="stylesheet" href="../static/styles/main.css">
 </head>
 <body>
  <div class="topnav">
   <a href="/">Home</a>
   <a href="/page/campuses">Campuses</a>
   <a href="/page/degree">Degrees</a>
   <a class="active" href="/page/department">Departments</a>
   <a href="/page/professor">Staff Directory</a>
   <a href="/course_search">Course Search</a>
   <a href="/page/schedule">Schedule Builder</a>
   <a href="/page/login">Login</a>
  </div>
  <div id="root">Loadingâ€¦</div>

  {%- raw %}
  <script type="text/babel">
   function App() {
    const [departments, setDepartments] = React.useState([]);

    React.useEffect(() => {
     fetch("/api/departments")
       .then(r => r.json())
       .then(setDepartments)
       .catch(console.error);
    }, []);

    return (
     <div>
      <h1>Departments</h1>
      <div className="campus-grid">
       {departments.map(department => (
        <div key={department.departmentID} className="campus-item">
         <div>
          {department.department_name}
         </div>
        </div>
       ))}
      </div>
     </div>
    );
   }

   ReactDOM.createRoot(document.getElementById("root")).render(<App/>);
  </script>
  {%- endraw %}
 </body>
 </html>
 ```

```python
 <llm-snippet-file>app.py</llm-snippet-file>
 ```python
 from flask import Flask, render_template, request, redirect, url_for, session, jsonify
 import mysql.connector
 import os
 from functools import wraps
 from dotenv import load_dotenv

 load_dotenv()

 app = Flask(__name__)
 app.secret_key = os.environ.get('SECRET_KEY')

 # Database configuration
 DB_CONFIG = {
  'user': os.environ.get('DB_USER'),
  'password': os.environ.get('DB_PASSWORD'),
  'host': os.environ.get('DB_HOST'),
  'database': os.environ.get('DB_DATABASE'),
 }


 def get_db_conn():
  """Establish a database connection."""
  try:
   conn = mysql.connector.connect(**DB_CONFIG)
   return conn
  except mysql.connector.Error as e:
   print(f"DB connection error: {e}")
   return None


 def close_db_conn(conn):
  """Close the database connection."""
  if conn:
   conn.close()


 def get_user_by_username(username):
  """Fetch a user from the database by username."""
  conn = get_db_conn()
  if not conn:
   return None

  try:
   cursor = conn.cursor(dictionary=True)
   query = "SELECT userID, username, password, role FROM user WHERE username = %s"
   cursor.execute(query, (username,))
   user = cursor.fetchone()
   return user
  except mysql.connector.Error as e:
   print(f"DB query error: {e}")
   return None
  finally:
   if conn.is_connected():
    cursor.close()
    conn.close()


 def get_user_roles(userID):
  """Fetch a user's roles from the database by userID."""
  conn = get_db_conn()
  if not conn:
   return None

  try:
   cursor = conn.cursor(dictionary=True)
   query = """
            SELECT r.role_name
            FROM user_roles ur
            JOIN role r ON ur.roleID = r.roleID
            WHERE ur.userID = %s
            """
   cursor.execute(query, (userID,))
   roles = [row['role_name'] for row in cursor.fetchall()]
   return roles
  except mysql.connector.Error as e:
   print(f"DB query error: {e}")
   return None
  finally:
   if conn.is_connected():
    cursor.close()
    conn.close()


 def authenticate_user(username, password):
  """Verify user credentials."""
  user = get_user_by_username(username)
  if user and user['password'] == password:
   return user
  return None


 def create_new_user(username, password, role):
  """Create a new user in the database."""
  conn = get_db_conn()
  if not conn:
   return None

  try:
   cursor = conn.cursor()
   query = "INSERT INTO user (username, password, role) VALUES (%s, %s, %s)"
   cursor.execute(query, (username, password, role))
   conn.commit()
   userID = cursor.lastrowid

   # Fetch the roleID based on the role name
   cursor.execute("SELECT roleID FROM role WHERE role_name = %s", (role,))
   role_record = cursor.fetchone()

   if role_record:
    roleID = role_record[0]
    # Insert the new user's role into the user_roles table
    query = "INSERT INTO user_roles (userID, roleID) VALUES (%s, %s)"
    cursor.execute(query, (userID, roleID))
    conn.commit()
   else:
    print(f"Role '{role}' not found in the role table.")
    conn.rollback()  # Rollback the user creation if the role is not found
    return None

   return userID
  except mysql.connector.Error as e:
   conn.rollback()  # Rollback the transaction if an error occurs
   print(f"DB error: {e}")
   return None
  finally:
   if conn.is_connected():
    cursor.close()
    conn.close()


 @app.route('/create_user', methods=['GET', 'POST'])
 def create_user_route():
  """Route to handle user creation."""
  if request.method == 'POST':
   username = request.form['username']
   password = request.form['password']
   role = request.form['role']

   # Create the new user
   user_id = create_new_user(username, password, role)

   if user_id:
    # Redirect to login page after successful registration
    return redirect(url_for('login'))
   else:
    # Display an error message if registration fails
    return render_template('create_user.html', error='Registration failed. Please try again.')

  return render_template('create_user.html')


 @app.route('/login', methods=['GET', 'POST'])
 def login():
  """Route to handle user login."""
  if request.method == 'POST':
   username = request.form['username']
   password = request.form['password']
   user = authenticate_user(username, password)

   if user:
    session['user_id'] = user['userID']
    session['username'] = user['username']
    session['role'] = user['role']
    return redirect(url_for('dashboard'))
   else:
    return render_template('login.html', error='Invalid credentials')
  return render_template('login.html')


 @app.route('/logout')
 def logout():
  """Route to handle user logout."""
  session.pop('user_id', None)
  session.pop('username', None)
  session.pop('role', None)
  return redirect(url_for('index'))


 def login_required(f):
  """Decorator to require login for a route."""

  @wraps(f)
  def decorated_function(*args, **kwargs):
   if session.get('user_id') is None:
    return redirect(url_for('login', next=request.url))
   return f(*args, **kwargs)

  return decorated_function


 @app.route('/dashboard')
 @login_required
 def dashboard():
  """Route for the user dashboard."""
  username = session.get('username')
  user_id = session.get('user_id')
  role = session.get('role')
  return render_template('dashboard.html', username=username, user_id=user_id, role=role)


 @app.route('/')
 def index():
  """Route for the index page."""
  return render_template('index.html')


 @app.route('/course_search', methods=['GET'])
 def course_search():
  """Route for course search."""
  conn = get_db_conn()
  cursor = conn.cursor(dictionary=True)

  # Fetch all degrees for the degree filter
  cursor.execute("SELECT degreeID, degree_name FROM degree")
  degrees = cursor.fetchall()

  # Get filter parameters from the request
  filters = {
   'prof_name': request.args.get('prof_name', ''),
   'min_credits': request.args.get('min_credits', ''),
   'max_credits': request.args.get('max_credits', ''),
   'degree_id': request.args.get('degree_id', '')
  }

  # Construct the query based on the filters
  query = """
        SELECT c.courseID, c.course_name, c.credits
        FROM course c
        LEFT JOIN course_degree cd ON c.courseID = cd.courseID
        WHERE 1=1
    """
  params = []

  if filters['min_credits']:
   query += " AND c.credits >= %s"
   params.append(filters['min_credits'])
  if filters['max_credits']:
   query += " AND c.credits <= %s"
   params.append(filters['max_credits'])
  if filters['degree_id']:
   query += " AND cd.degreeID = %s"
   params.append(filters['degree_id'])

  cursor.execute(query, params)
  courses = cursor.fetchall()

  # If the user entered a professor name, search for sections taught by that professor
  sections = []
  if filters['prof_name']:
   prof_name = filters['prof_name']
   query = """
            SELECT s.courseID, c.course_name, c.credits, p.prof_name
            FROM section s
            JOIN course c ON s.courseID = c.courseID
            JOIN professor p ON s.profID = p.profID
            WHERE p.prof_name LIKE %s
        """
   cursor.execute(query, [f"%{prof_name}%"])
   sections = cursor.fetchall()

  cursor.close()
  conn.close()

  return render_template('course_search.html', courses=courses, degrees=degrees, filters=filters,
                         sections=sections)


 @app.route('/page/<page_name>')
 def load_page(page_name):
  """Generic route to load static pages."""
  return render_template(f'{page_name}.html')


 @app.route("/api/campus")
 def api_items():
  conn = get_db_conn()
  cursor = conn.cursor(dictionary=True)
  cursor.execute("SELECT campusID, campus_name, image_src, url, country FROM campus")
  items = cursor.fetchall()
  cursor.close();
  conn.close()
  return jsonify(items)


 @app.route("/api/schools")
 def school_items():
  conn = get_db_conn()
  cursor = conn.cursor(dictionary=True)
  cursor.execute("SELECT schoolID, school_name FROM school")
  items = cursor.fetchall()
  cursor.close();
  conn.close()
  return jsonify(items)


 @app.route("/api/degrees")
 def degree_items():
  schoolID = request.args.get('schoolID')
  conn = get_db_conn()
  cursor = conn.cursor(dictionary=True)
  query = "SELECT degreeID, degree_name, description, url FROM degree"
  if schoolID:
   query += " WHERE schoolID = %s"
   cursor.execute(query, (schoolID,))
  else:
   cursor.execute(query)
  items = cursor.fetchall()
  cursor.close();
  conn.close()
  return jsonify(items)


 @app.route("/api/professor")
 def professor_items():
  departmentID = request.args.get('departmentID')
  conn = get_db_conn()
  cursor = conn.cursor(dictionary=True)
  query = "SELECT profID, prof_name, email, phone, office FROM professor"
  if departmentID:
   query += " WHERE departmentID = %s"
   cursor.execute(query, (departmentID,))
  else:
   cursor.execute(query)
  items = cursor.fetchall()
  cursor.close();
  conn.close()
  return jsonify(items)


 @app.route("/api/departments")
 def department_items():
  conn = get_db_conn()
  cursor = conn.cursor(dictionary=True)
  cursor.execute("SELECT departmentID, department_name FROM department")
  items = cursor.fetchall()
  cursor.close();
  conn.close()
  return jsonify(items)


 @app.route("/schedule_maker", methods=['GET', 'POST'])
 def schedule_maker():
  conn = get_db_conn()
  cursor = conn.cursor(dictionary=True)

  # fetch filter options
  cursor.execute("SELECT DISTINCT campus_available FROM section")
  campuses = [r['campus_available'] for r in cursor.fetchall()]

  # default filters
  filters = {
   'p_department': request.args.get('p_department', ''),
   'p_courseID': request.args.get('p_courseID', ''),
   'p_professor': request.args.get('p_professor', ''),
   'p_min_credits': request.args.get('p_min_credits', ''),
   'p_max_credits': request.args.get('p_max_credits', ''),
   'p_campus_available': request.args.get('p_campus_available', ''),
  }

  # build query
  query = """
        SELECT s.*, c.course_name
        FROM section s JOIN course c ON s.courseID = c.courseID
        WHERE 1=1
    """
  params = []
  if filters['p_department']:
   query += " AND s.departmentID = %s"
   params.append(filters['p_department'])
  if filters['p_courseID']:
   query += " AND s.courseID = %s"
   params.append(filters['p_courseID'])
  if filters['p_professor']:
   query += " AND s.profID = %s"
   # params.append(filters['p_professor'])  # must be profID
   query += " AND s.profID IN (SELECT profID FROM professor WHERE prof_name LIKE %s)"
   params.append(f"%{filters['p_professor']}%")
  if filters['p_min_credits']:
   query += " AND c.credits >= %s"
   params.append(filters['p_min_credits'])
  if filters['p_max_credits']:
   query += " AND c.credits <= %s"
   params.append(filters['p_max_credits'])
  if filters['p_campus_available']:
   query += " AND s.campus_available = %s"
   params.append(filters['p_campus_available'])
  query += " LIMIT 25"

  # execute
  cursor.execute(query, params)
  schedule = cursor.fetchall()
  cursor.close()
  conn.close()

  return render_template('schedule.html',
                         campuses=campuses,
                         schedule=schedule,
                         filters=filters)


 @app.route("/enroll", methods=['POST'])
 @login_required
 def enroll():
  userID = session['user_id']
  sectionID = request.form['sectionID']

  conn = get_db_conn()
  cursor = conn.cursor()
  try:
   sql = "INSERT INTO enrollment (userID, sectionID) VALUES (%s, %s)"
   cursor.execute(sql, [userID, sectionID])
   conn.commit()
   msg = "Enrolled!"
  except Exception as err:
   msg = "Enrollment FAILED!" + str(err)
   conn.rollback()

  cursor.close()
  conn.close()
  return f"<p>{msg}</p>"


 @app.route("/drop", methods=['POST'])
 @login_required
 def drop():
  userID = session['user_id']
  sectionID = request.form['sectionID']

  conn = get_db_conn()
  cursor = conn.cursor()
  try:
   sql = "DELETE FROM enrollment WHERE userID=%s AND sectionID=%s"
   cursor.execute(sql, [userID, sectionID])
   conn.commit()
   msg = "Dropped!"
  except Exception as err:
   msg = "Drop FAILED!" + str(err)
   conn.rollback()

  cursor.close()
  conn.close()
  return f"<p>{msg}</p>"


 if __name__ == '__main__':
  app.run(debug=True)
 ```

Key changes:

*   **department.html:**
    *   The React component now fetches data from `/api/departments`.
    *   The component maps through the `departments` array and renders each `department_name` inside a `div` with the class names `"campus-grid"` and `"campus-item"`.
*   **app.py:**
    *   Added the `/api/departments` route to query all department names and department IDs, and return them as a JSON array.

This setup will fetch the department data from the database and display it in a grid format similar to the campuses page.